\section{Feature Engineering}\label{sec:ccm}
With a collection of extracted templates from each spectrogram, feature vectors
can be constructed to distinguish between various bird species.
This is done through cross-correlation mapping, an image recognition algorithm.
A feature vector is derived from the results of cross-correlating all
templates against samples of known species.
These feature vectors are then used to train a machine learning algorithm to
classify new recordings from their spectrograms.

This section describes the mechanisms used to perform cross-correlation mapping
for feature vector construction and a short analysis of the computational
expense involved.

\subsection{Batch Processing}
Once initial reductions have been made through the selection process,
further processing is batched in groups of four species, which are selected in
random order without replacement.
Each batch undergoes template matching, the results of which are stored on disk.
Once a batch is completed it is merged with previous results by cross-template
matching the new templates against the old spectrograms and the old templates
against the new spectrograms.
The new results are appended to the old feature vectors and stored on disk.

This is an effective method for dividing work into managable chunks while storing
intermediate results.
Each batch takes approximately 22 hours to complete.
This is based on statistics taken from a single batch with 12200 templates.
Merging batches takes at least 44 hours, and is dependent on the amount of
templates used in the previous data.
Memory consumption is approximately 11GB per batch including overhead from
the repository data store, and rises during batch merges.

\subsection{Cross-correlation Mapping}
Cross-correlation mapping, also referred to as template matching, is
a method for computing the similarity of an image with another.
More precisely, it computes the correlation of each pixel in the template image
with those of the target image.
The template may be of the same size or smaller than the target.
The cross correlation map will indicate areas of high correlation with brighter
pixels, which is essentially a form of image recognition.
The intuition is that recordings of songs from birds of the same species will
have very similar spectra.

Cross-correlation mapping works by convolving the template image
over the target image and measuring the pixel similarities.
\textbf{check this..}
The result can be visualised as a heatmap where pixel intensity corresponds to
the amount of correlation.
An example of this is shown in figure (ref), where the template (ref) is matched
against the spectrogram (ref).

The Open-CV library is used to perform template matching.
Open-CV's implementation is highly optimized.
Template matchign performance is highly important in this project as it is the
most expensive operation when classifying recordings.
Open-CV's template matching function may be executed on GPU, although this is
not done in this project due to the lack of required hardware.
Performance analysis is detailed in Section (ref).


we do normalised cross correlation mappinbg

\begin{figure}[t!]
  \centering
  \begin{subfigure}[t]{0.5\textwidth}
    \centering
    \caption{}
  \end{subfigure}
  \begin{subfigure}[t]{0.5\textwidth}
    \centering
    \caption{}
  \end{subfigure}
  \caption{Cross-correlation map of template (a) against spectrogram (b)}
\end{figure}

\subsubsection{Optimizations}
Due to the computational expense of performing template matching, some effort is
taken to optimise performance in this area:

\begin{itemize}
  \item Dimensionality reduction is performed on templates and spectrograms by
blurring and reducing their size (see Section~\ref{sec:extract}).

  \item The template matching operation is done in a multithreaded manner.
The workload is split into balanced partitions according to the number of
available CPU cores.

  \item Although not implemented in this project, template matching can be
confined to a specific area of interest.
This is conceivable if the spectral frequencies at which a template was extracted
is stored.
The template matching algorithm can then be limited by this frequency with an
additional padding value.
\end{itemize}

Even with these performance optimizations, template matching still takes a
considerable amount of time.

\subsubsection{Computation time}
Template matching takes approximately x minutes per template, given
mean dimensions of mxn and ixj for spectrograms and templates respectively.
Considering the quantity of templates stored in the database, the time
required quickly compounds into the order of days.
xx templates against yy spectrograms was measured at x days on a xyz machine.
This stresses the requirement for optimization, which is the topic of
section blah.

As template matching is multithreaded, the time is cut by approximately a
quarter, from 1000 hours to 1 second.


\subsection{Feature Vector Construction}
Each sample is represented as a feature vector.
Our model takes into consideration only the maxima of each cross-correlation
mapping.
In this manner, each feature is directly associated with a specific template,
which allows us to analyse the impact of each feature and the performance of the
template extraction mechanism.
The maxima was chosen as it has shown promising results in (ref gabor fodor).
Template analysis is discussed in Section~\ref{sec:feature_imp}.

