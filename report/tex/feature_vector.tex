\section{Feature Engineering}\label{sec:ccm}
With the collection of extracted templates from each spectrogram,
a model can now be constructed for a particular sample.
This model is represented as a feature vector consisting of the maxima
of each template cross correlation operation done on the spectrogram.
This vector will then be compared to those of other samples using a
classifier.
This section describes in detail the operation of template matching
used to build this feature vector, as well as some notes on the time required.

\subsection{Batch Processing}
Once initial reductions have been made through the selection process,
further processing is batched in groups of four species, which are selected in
random order without replacement.
Each batch undergoes template matching, the results of which are stored on disk.
Once a batch is completed it is merged with previous results by cross-template
matching the new templates against the old spectrograms and the old templates
against the new spectrograms.
The new results are appended to the old feature vectors and stored on disk.

This is an effective method for dividing work into managable chunks while storing
intermediate results.
Each batch takes approximately 12 hours to complete.
Merging batches takes at least 12 hours, and is dependent on the amount of
templates used in the previous data.
Memory consumption is approximately 6GB per batch, and rises exponentially
during batch merges.

\subsection{Cross-correlation Mapping}
Cross-correlation mapping, also referred to as template matching, is
a method for computing the similarity of an image with another.
More precisely, it computes the correlation of each pixel in the template image
with those of the target image.
The template may be of the same size or smaller than the target.
The cross correlation map will indicate areas of high correlation with brighter
pixels, which is essentially a form of image recognition.
The intuition is that recordings of songs from birds of the same species will
have very similar spectra.

Cross-correlation mapping works by convolving the template image
over the target image and measuring the pixel similarities.
\textbf{check this..}
The result can be visualised as a heatmap where pixel intensity corresponds to
the amount of correlation.
An example of this is shown in figure (ref), where the template (ref) is matched
against the spectrogram (ref).

The Open-CV library is used to perform template matching.
Open-CV's implementation is highly optimized.
Template matchign performance is highly important in this project as it is the
most expensive operation when classifying recordings.
Open-CV's template matching function may be executed on GPU, although this is
not done in this project due to the lack of required hardware.
Performance analysis is detailed in Section (ref).

\subsection{Feature Vector Construction}
Each sample is represented as a feature vector.
Our model takes into consideration only the maxima of each cross-correlation
mapping.
In this manner, each feature is directly associated with a specific template,
which allows us to analyse the impact of each feature and the performance of the
template extraction mechanism.
The maxima was chosen as it has shown promising results in (ref gabor fodor).
Template analysis is discussed in Section~\ref{sec:feature_imp}.

\subsubsection{Optimizations}
Due to the computational expense of performing template matching, some effort is
taken to optimise performance in this area:

\begin{itemize}
  \item Dimensionality reduction is performed on templates and spectrograms by
blurring and reducing their size (see Section~\ref{sec:extract}).

  \item The template matching operation is done in a multithreaded manner.
The workload is split into balanced partitions according to the number of
available CPU cores.

  \item Although not implemented in this project, template matching can be
confined to a specific area of interest.
This is conceivable if the spectral frequencies at which a template was extracted
is stored.
The template matching algorithm can then be limited by this frequency with an
additional padding value.
\end{itemize}

Even with these performance optimizations, template matching still takes a
considerable amount of time.

\subsubsection{Time cost}
Template matching takes approximately x minutes per template, given
mean dimensions of mxn and ixj for spectrograms and templates respectively.
Considering the quantity of templates stored in the database, the time
required quickly compounds into the order of days.
xx templates against yy spectrograms was measured at x days on a xyz machine.
This stresses the requirement for optimization, which is the topic of
section blah.

As template matching is multithreaded, the time is cut by approximately a
quarter, from 1000 hours to 1 second.
